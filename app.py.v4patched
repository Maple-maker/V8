import os, tempfile, re
from flask import Flask, request, send_file, render_template_string

from pypdf import PdfReader, PdfWriter
from pypdf._page import PageObject

from reportlab.platypus import Paragraph
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.colors import black
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter # Still used as a fallback
from reportlab.lib.units import inch

VERSION = "2025-12-31.flask.v7.dynamic-layout"

HTML = """
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>BOM → DD1750</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;max-width:980px;margin:40px auto;padding:0 16px}
    .box{border:1px solid #ddd;border-radius:10px;padding:18px;margin:16px 0}
    label{display:block;margin:10px 0 4px}
    input,select{padding:8px;width:100%}
    button{padding:10px 14px;border:0;border-radius:8px;background:#111;color:#fff;cursor:pointer}
    small{color:#555}
    .row{display:flex;gap:18px}
    .col{flex:1}
  </style>
</head>
<body>
  <h2>BOM → DD1750</h2>
  <p><small>Version: {{version}}</small></p>

  <div class="box">
    <form method="post" action="/generate" enctype="multipart/form-data">
      <div class="row">
        <div class="col">
          <label>BOM (PDF)</label>
          <input type="file" name="bom" accept=".pdf" required>
        </div>
        <div class="col">
          <label>Blank DD1750 template (PDF)</label>
          <input type="file" name="template" accept=".pdf" required>
        </div>
      </div>

      <div class="row">
        <div class="col">
          <label>Label under description</label>
          <select name="label">
            <option value="NSN" selected>NSN</option>
            <option value="SN">SN</option>
          </select>
        </div>
        <div class="col">
          <label>Start parsing BOM at page (0-based)</label>
          <input type="number" name="start_page" value="0" min="0">
        </div>
      </div>

      <p><small>Uses PDF text extraction. If your BOM is scanned, OCR it (Adobe “Recognize Text”) before upload.</small></p>

      <button type="submit">Generate DD1750</button>
    </form>
  </div>
</body>
</html>
"""

app = Flask(__name__)

# ---------- BOM Parsing (No changes needed here) ----------

MAT_RE = re.compile(r'\b(\d{9})\b')
QTY_RE = re.compile(r"(\d+)\s*$")

def looks_like_qty_line(s: str) -> bool:
    u = s.upper()
    return any(tok in u for tok in [" X ", " U ", " EA ", " AY ", "9G", "9K", "SCMC", "CIIC"])

def is_header_noise(s: str) -> bool:
    u = s.upper()
    return any(h in u for h in [
        "LV", "DESCRIPTION", "WTY", "ARC", "CIIC", "UI", "SCMC", "AUTH", "OH QTY",
        "COMPONENT OF END ITEM", "PAGE", "COEI", "IMAGE", "MATERIAL", "DATE:",
        "PUB NUM:", "END ITEM NIIN:", "COMPONENT LISTING"
    ])

def normalize_desc(s: str) -> str:
    s = re.sub(r"\s{2,}", " ", s).strip()
    return s

def is_valid_desc_line(s: str) -> bool:
    if not s or is_header_noise(s) or looks_like_qty_line(" " + s + " "):
        return False
    if ' ' not in s and ('~' in s or '_' in s or '-' in s):
        return False
    if re.fullmatch(r'[A-Z]', s):
        return False
    return True

def extract_items_bom_style(pdf_path: str, start_page: int = 0):
    reader = PdfReader(pdf_path)
    full_text = ""
    for pi in range(start_page, len(reader.pages)):
        full_text += (reader.pages[pi].extract_text() or "") + "\n"
    items = []
    chunks = MAT_RE.split(full_text)
    for i in range(1, len(chunks), 2):
        mat = chunks[i]
        text_chunk = chunks[i+1]
        if not text_chunk: continue
        lines = [l.strip() for l in text_chunk.splitlines() if l.strip()]
        qty = None
        desc_parts = []
        for line in lines:
            if looks_like_qty_line(" " + line + " "):
                qm = QTY_RE.search(line)
                if qm:
                    qty = int(qm.group(1))
            elif is_valid_desc_line(line):
                desc_parts.append(line)
        if mat and desc_parts and qty is not None and qty > 0:
            items.append({"desc": normalize_desc(" ".join(desc_parts)), "mat": mat, "qty": qty})
    dedup = []
    seen = set()
    for it in items:
        key = (it["desc"], it["mat"], it["qty"])
        if key not in seen:
            seen.add(key)
            dedup.append(it)
    return dedup

def paginate(items, per_page=18):
    return [items[i:i+per_page] for i in range(0, len(items), per_page)] or [[]]

# ---------- DD1750 Overlay (DEFINITIVE FIX: DYNAMIC LAYOUT) ----------

def make_overlay(pages, label, template_pdf_path):
    # 1. Read the template to get its exact dimensions
    template_reader = PdfReader(template_pdf_path)
    if not template_reader.pages:
        raise ValueError("Template PDF is empty.")
    template_page = template_reader.pages[0]
    page_width = float(template_page.mediabox.width)
    page_height = float(template_page.mediabox.height)

    tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf")
    # 2. Create a canvas with the EXACT same size as the template
    c = canvas.Canvas(tmp.name, pagesize=(page_width, page_height))
    
    # --- STYLES ---
    styles = getSampleStyleSheet()
    desc_style = ParagraphStyle('DescStyle', parent=styles['Normal'], fontName='Helvetica', fontSize=9, leading=10, textColor=black)
    nsn_style = ParagraphStyle('NsnStyle', parent=styles['Normal'], fontName='Helvetica', fontSize=8, leading=9, textColor=black)
    
    # 3. Use percentages to calculate all coordinates dynamically
    # These percentages were measured from the dd1750.pdf form
    x_box_center = page_width * 0.125
    x_contents_left = page_width * 0.185
    x_uoi_center = page_width * 0.725
    x_init_center = page_width * 0.825
    x_spares_center = page_width * 0.915
    x_total_center = page_width * 0.985 # Pushed to the right edge

    top = page_height * 0.76  # Top of the first writable row
    bottom = page_height * 0.12 # Bottom of the last writable row
    
    per_page = 18
    row_h = (top - bottom) / per_page
    
    for p, rows in enumerate(pages, start=1):
        current_y = top
        for idx, it in enumerate(rows, start=1):
            row_bottom_y = current_y - row_h
            center_y = row_bottom_y + row_h / 2 - 4 # Vertical center for single-line text

            # Column (a) Box No.
            c.setFont("Helvetica", 9)
            c.drawCentredString(x_box_center, center_y, str((p-1)*per_page + idx))

            # Column (b) Contents (with wrapping)
            content_width = x_uoi_center - x_contents_left - (page_width * 0.01)
            desc_p = Paragraph(it['desc'], desc_style)
            w_d, h_d = desc_p.wrap(content_width, row_h * 0.6) # Use 60% of row height for desc
            desc_p.drawOn(c, x_contents_left, current_y - h_d - (row_h * 0.1)) # Position desc from top

            nsn_p = Paragraph(f"{label}: {it['mat']}", nsn_style)
            w_n, h_n = nsn_p.wrap(content_width, row_h * 0.4) # Use 40% of row height for nsn
            nsn_p.drawOn(c, x_contents_left, row_bottom_y + (row_h * 0.05)) # Position nsn from bottom

            # Other Columns
            c.setFont("Helvetica", 9)
            c.drawCentredString(x_uoi_center, center_y, "EA")
            c.drawCentredString(x_init_center, center_y, str(it['qty']))
            c.drawCentredString(x_spares_center, center_y, "0")
            c.drawCentredString(x_total_center, center_y, str(it['qty']))
            
            current_y -= row_h
        c.showPage()
    c.save()
    return tmp.name

def merge_with_template(template_pdf: str, overlay_pdf: str, out_pdf: str):
    tpl = PdfReader(template_pdf)
    ov = PdfReader(overlay_pdf)
    writer = PdfWriter()
    base = tpl.pages[0]
    for ovp in ov.pages:
        merged = PageObject.create_blank_page(width=base.mediabox.width, height=base.mediabox.height)
        merged.merge_page(base)
        merged.merge_page(ovp)
        writer.add_page(merged)
    with open(out_pdf, "wb") as f:
        writer.write(f)

@app.get("/")
def home():
    return render_template_string(HTML, version=VERSION)

@app.post("/generate")
def generate():
    if "bom" not in request.files or "template" not in request.files:
        return "Missing files", 400

    bom = request.files["bom"]
    template = request.files["template"]
    label = request.form.get("label", "NSN")
    start_page = int(request.form.get("start_page", "0") or "0")

    with tempfile.TemporaryDirectory() as td:
        bom_path = os.path.join(td, "bom.pdf")
        tpl_path = os.path.join(td, "template.pdf")
        bom.save(bom_path)
        template.save(tpl_path)

        items = extract_items_bom_style(bom_path, start_page=start_page)
        if not items:
            return "Could not parse any items from the BOM. Please ensure the PDF is not a scanned image and contains selectable text.", 400

        pages = paginate(items, per_page=18)
        # Pass the template path to the overlay function
        overlay = make_overlay(pages, label=label, template_pdf_path=tpl_path)
        out_pdf = os.path.join(td, "DD1750_OUTPUT.pdf")
        merge_with_template(tpl_path, overlay, out_pdf)

        return send_file(out_pdf, as_attachment=True, download_name="DD1750_OUTPUT.pdf", mimetype="application/pdf")

if __name__ == "__main__":
    port = int(os.environ.get("PORT", "8080"))
    app.run(host="0.0.0.0", port=port)
